a^n * a^n = a^2n
12^58 = 4(mod 67) -> 12^116 = 16(mod 67)
// 12의 58제곱은 67로 나눈 나머지가 4이다,
// 12의 116제곱은 67로 나눈 나머지가 16이다
1번 도미노가 쓰러진다.
k번 도미노가 쓰러지면 k+1 도미노도 쓰러진다.

1승을 계산할 수 있다.
k승을 계산했으면 2k승과 2k+1승도 O(1)에 계산할 수 있다.



// mod 연산 = 나머지 연산(%)

// 재귀 함수의 조건
// 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함(Base condition)
// 모든 입력은 base condition으로 수렴해야 함
// 애초에 A^B 다 곱해준 후 %C 로 답을 구하면 integer overflow 로 작동이 안됨.
// 그러므로 분할해서 생각
// 그리고 type도 long long으로 바꿔주면 더 좋겠습니다. 
//int overflow를 고려한 코드는 확인해보세요. 코드를 보면 m 미만의 수 2개를 곱하는 상황이 계속 발생하니
// m이 232 보다 크다면 long long의 범위조차 넘어설 수 있습니다.

#include <bits/stdc++.h>
using namespace std;

using ll = long long;

ll POW(ll a, ll b, ll m) {
    if(b==1) return a % m; 
    // base conditon -> 그리고 return에 별다른 연산이 없으면 
    // 종료조건이 리턴의 시작. a % m 의 리턴을 가지고 올라감 
    // 왜냐면 val 의 pow call에서 변화가 없으니 그냥 a%m 을 가지고 올라간다고 생각함(그냥 내 추측)
    ll val = POW(a, b/2, m);
    val = val * val % m; 
    // 문제가 요구하는건 m으로 나눈 나머지를 구하는 것이다. 
    if(b%2 == 0) return val;
    return val * a % m;
    // 여기서 val*a 를 하면 안되는게 리턴이 (a%m)*(a%m) 을 들고다녀야 하는게 조건인데
    // 그냥 a를 곱해서 리턴값이 *a 만큼 커지게 되는것.
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);
    ll a,b,c;
    cin >> a >> b >> c;
    cout << POW(a,b,c);
}


2023.8.25 첫번째 통찰
//  귀납법을 이용해 식을 세우고 나머지는 컴퓨터에게 맡기기. 
// 절차적으로 어떻게 프로그램이 흘러가는지는 전혀 신경 안써도 됨
// 지금 나는 위 함수식에서 pow(a, b/2, m) 이 어떻게 흐르는지에 매몰되서 2시간을 붙잡혀있는데,
// ★★★★ 그냥 pow는 A^B%C 를 의미하는 함수이다 ~ 하고 생각하고 그냥 과감하게 식을 쓰기. ★★★★
// ★★★★ 이게 어떤 방식으로 A^B%C를 만드는지 절차적으로 생각할 필요 없음 ★★★★

//원판이 1개일 때 원판을 내가 원하는 곳으로 옮길 수 있다.
//원판이 k개일 때 옮길 수 있으면 원판이 k+1개일 때에도 옮길 수 있다.

// 1. 위와 같이 B=0 일때 return 1; 처럼 B=0일때 값을 알거나 B=1일때 return a%m 처럼 1의 값을 안다.
// 2. 나는 k일때의 a%m 을 알 수 있다 -> k+1도 알 수 있다 처럼 그냥 과감하게 귀납적으로(빠르게 일반화)